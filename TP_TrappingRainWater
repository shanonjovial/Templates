### Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
### Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6

#### OPTION 1: Brute Force ####
# Time complexity: O(n^2)
# Space complexity: O(1)O(1)
def trap1(height):
    if not height or len(height) < 3:
        return 0    
    ans, size = 0, len(height)
    for i in range (1, size-1):
        max_left = max_right = 0
        for j in range(i-1, -1, -1):
            max_left = max(max_left, height[j])
        for j in range(i+1, size):
            max_right = max(max_right, height[j])
        ans +=  max(0, min(max_left, max_right) - height[i])
    
    return ans
    
#### OPTION 2: Dynamic Programming ####
# Time complexity: O(n)
# Space complexity: O(n)
def trap2(height):
    if not height or len(height) < 3:
        return 0
    ans, size = 0, len(height)
    left_max, right_max, anss = [0] * size, [0] * size, [0] * size
    left_max[0] = height[0]
    for i in range (1, size):
        left_max[i] = max(height[i], left_max[i-1])
    right_max[-1] = height[-1]
    for i in range (size-2, -1, -1):
        right_max[i] = max(height[i], right_max[i+1])
    for i in range (1, size-1):
        anss[i] =  min(left_max[i], right_max[i]) - height[i]
        ans += min(left_max[i], right_max[i]) - height[i]

    return ans


#### OPTION 3: Two Pointers ####
# Time complexity: O(n)
# Space complexity: O(1)
def trap3(height):
    if not height or len(height) < 3:
        return 0
    left, right = 0, len(height) - 1
    left_max, right_max = 0, 0
    ans = 0
    while (left < right):
        if (height[left] < height[right]):
            if height[left] >= left_max:
                left_max = height[left]  
            else:
                ans += (left_max - height[left])
            left += 1
        
        else:
            if height[right] >= right_max:
                right_max = height[right] 
            else:
                ans += (right_max - height[right])
            right -= 1
    return ans;
   

#### Stack ####
# Time complexity: O(n)
# Space complexity: O(n)
def trap4(height): 
    ans, current = 0, 0
    st = []
    while (current < len(height)):
        while (len(st) != 0 and height[current] > height[st[-1]]):
            top = st[-1]
            print("current: ", current, "   top: ", top)
            print("before: ", st)
            st.pop()
            if len(st) == 0:
                break
            distance = current - st[-1] - 1
            bounded_height = min(height[current], height[st[-1]]) - height[top]
            ans += distance * bounded_height
            print("after: ", st)
        st.append(current)
        current += 1
    return ans






